# Futures, closures and state
## The task
Let's say we are writing an asynchronous application.
We may come up with a design like this.

```Rust
struct App {
    counter: i32 // in real world we'll have many useful fields here instead
}

impl App {
    fn new() -> App {
        unimplemented!()
    }

    fn start<'a>(&'a mut self) -> impl Future<Item=i32, Error=()> + 'a {
        unimplemented!()
    }
}

fn main() {
    // just start our app on Tokio Core
    let mut core = Core::new().unwrap();
    let mut app = App::new();
    let f = app.start();
    core.run(f).unwrap();
}
```

## The problem
A naive implementation of ```start`` fails however.
```Rust
impl App {
    fn start<'a>(&'a mut self) -> impl Future<Item=i32, Error=()> + 'a {
        self.counter = 0;
        futures::finished(0)
            .map(|x| x + self.counter)
            .map(|x| x + self.counter)
    }
}
```
The compiler is not happy:
```
error[E0373]: closure may outlive the current function, but it borrows `self`, which is owned by the current function
  --> src/main.rs:17:18
   |
17 |             .map(|x| x + self.counter)
   |                  ^^^     ---- `self` is borrowed here
   |                  |
   |                  may outlive borrowed value `self`
help: to force the closure to take ownership of `self` (and any other referenced variables), use the `move` keyword
   |
17 |             .map(move |x| x + self.counter)
   |                  ^^^^^^^^
```
Closures are essentially anonymous structures generated by compiler, holding a reference to used variables. If we want to return a closure from a function, we must follow the advice given by the compiler.
```Rust
impl App {
    fn start<'a>(&'a mut self) -> impl Future<Item=i32, Error=()> + 'a {
        self.counter = 0;
        futures::finished(0)
            .map(move |x| x + self.counter)
            .map(move |x| x + self.counter)
    }
}
```
However we get another error:
```
  --> src/main.rs:18:31
   |
17 |             .map(move |x| x + self.counter)
   |                  -------- value moved (into closure) here
18 |             .map(move |x| x + self.counter)
   |                               ^^^^ value captured here after move
   |
   = note: move occurs because `self` has type `&'a mut App`, which does not implement the `Copy` trait
```
The most important hint is the last line. Rust has two simple [rules](https://doc.rust-lang.org/book/second-edition/ch04-02-references-and-borrowing.html#the-rules-of-references) of borrowing. Basically, mutable reference doesn't allow us to have any other references to the object at the same time. Hence we cannot copy it or move twice to different closures.
## The solution
But, if we don't actually modify the state in the closures - we don't need mutable reference. So let's change our code to:
```Rust
impl App {
    fn start<'a>(&'a mut self) -> impl Future<Item=i32, Error=()> + 'a {
        self.init();
        self.start_work()
    }

    fn init<'a>(&'a mut self) {
        self.counter = 0;
    }

    fn start_work<'a>(&'a self) -> impl Future<Item=i32, Error=()> + 'a {
        futures::finished(0)
            .map(move |x| x + self.counter)
            .map(move |x| x + self.counter)
    }
}
```
Now it's working!

## What's next?
What if we actually need to modify state in the closures?
Read [next hint](./interior_mutability.html).